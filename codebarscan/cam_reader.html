<!DOCTYPE html>
<html>

<head>
	<title>lecteur de code barre</title>
	<link rel="shortcut icon" href="#" />
	<script src="zxing_reader.js"></script>
	<style>
		body {font-family: Arial, Helvetica, sans-serif;}

		/* The Modal (background) */
		.modal {
		  display: none; /* Hidden by default */
		  position: fixed; /* Stay in place */
		  z-index: 1; /* Sit on top */
		  padding-top: 100px; /* Location of the box */
		  left: 0;
		  top: 0;
		  width: 100%; /* Full width */
		  height: 100%; /* Full height */
		  overflow: auto; /* Enable scroll if needed */
		  background-color: rgb(0,0,0); /* Fallback color */
		  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
		}

		/* Modal Content */
		.modal-content {
		  background-color: #fefefe;
		  margin: auto;
		  padding: 20px;
		  border: 1px solid #888;
		  width: 80%;
		}

		/* The Close Button */
		.close {
		  color: #aaaaaa;
		  float: right;
		  font-size: 28px;
		  font-weight: bold;
		}

		.close:hover,
		.close:focus {
		  color: #000;
		  text-decoration: none;
		  cursor: pointer;
		}
		</style>
</head>

<body style="text-align: center">
		<!-- The Modal -->
		<div id="myModal" class="modal">

			<!-- Modal content -->
			<div class="modal-content">
			<span class="close">&times;</span>
			<div id="popupwide">Some text in the Modal..</div>
			</div>

		</div>
	<h2>lecteur de code barre</h2>
	<!-- <p>
		This is a simple demo of the wasm wrapper of <a href="https://github.com/zxing-cpp/zxing-cpp">zxing-cpp</a>
		scanning for barcodes in a live video stream.
	</p> -->

	Camera :
	<select id="cameraSelector">
		<option value="user">Front Camera</option>
		<option value="environment">Back Camera</option>
	</select>
	&nbsp;&nbsp;

	Format :
	<select id="format">
		<option value="" selected="">Any</option>
		<option value="Aztec">Aztec</option>
		<option value="Code39">Codabar</option>
		<option value="CODE_39">Code39</option>
		<option value="Code93">Code93</option>
		<option value="Code128">Code128</option>
		<option value="DataMatrix">DataMatrix</option>
		<option value="DataBar">DataBar</option>
		<option value="DataBarExpanded">DataBarExpanded</option>
		<option value="DataBarLimited">DataBarLimited</option>
		<option value="DXFilmEdge">DXFilmEdge</option>
		<option value="EAN8">EAN-8</option>
		<option value="EAN13">EAN-13</option>
		<option value="ITF">ITF</option>
		<option value="PDF417">PDF417</option>
		<option value="QRCode">QRCode</option>
		<option value="MicroQRCode">Micro QRCode</option>
		<option value="RMQRCode">rMQR Code</option>
		<option value="UPCA">UPC-A</option>
		<option value="UPCE">UPC-E</option>
		<option value="LinearCodes">Linear Codes</option>
		<option value="MatrixCodes">Matrix Codes</option>
	</select>
	&nbsp;&nbsp;

	Mode :
	<select id="mode">
		<option value="true" selected="">Normal</option>
		<option value="false">Fast</option>
	</select>
	<br /><br />

	<canvas id="canvas" width="640" height="480"></canvas>
	<br /><br />

	<div id="result"></div>

	<script>
		var zxing = ZXing().then(function (instance) {
			zxing = instance; // this line is supposedly not required but with current emsdk it is :-/
		});

		const cameraSelector = document.getElementById("cameraSelector");
		const format = document.getElementById("format");
		const mode = document.getElementById("mode");
		const canvas = document.getElementById("canvas");
		const resultElement = document.getElementById("result");

		const ctx = canvas.getContext("2d", { willReadFrequently: true });
		const video = document.createElement("video");
		video.setAttribute("id", "video");
		video.setAttribute("width", canvas.width);
		video.setAttribute("height", canvas.height);
		video.setAttribute("autoplay", "");

		function readBarcodeFromCanvas(canvas, format, mode) {
			var imgWidth = canvas.width;
			var imgHeight = canvas.height;
			var imageData = canvas.getContext('2d').getImageData(0, 0, imgWidth, imgHeight);
			var sourceBuffer = imageData.data;

			if (zxing != null) {
				var buffer = zxing._malloc(sourceBuffer.byteLength);
				zxing.HEAPU8.set(sourceBuffer, buffer);
				var result = zxing.readBarcodeFromPixmap(buffer, imgWidth, imgHeight, mode, format);
				zxing._free(buffer);
				return result;
			} else {
				return { error: "ZXing not yet initialized" };
			}
		}

		function drawResult(code) {
			ctx.beginPath();
			ctx.lineWidth = 4;
			ctx.strokeStyle = "red";
			// ctx.textAlign = "center";
			// ctx.fillStyle = "#green"
			// ctx.font = "25px Arial";
			// ctx.fontWeight = "bold";
			with (code.position) {
				ctx.moveTo(topLeft.x, topLeft.y);
				ctx.lineTo(topRight.x, topRight.y);
				ctx.lineTo(bottomRight.x, bottomRight.y);
				ctx.lineTo(bottomLeft.x, bottomLeft.y);
				ctx.lineTo(topLeft.x, topLeft.y);
				ctx.stroke();
				ctx.fillText(code.text, (topLeft.x + bottomRight.x) / 2, (topLeft.y + bottomRight.y) / 2);
			}
		}

		function escapeTags(htmlStr) {
			return htmlStr.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
		}

		const processFrame = function () {
			ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
			// draw codebar scanning zone
			ctx.beginPath();
			ctx.lineWidth = 4;

			ctx.strokeStyle = "green";
			ctx.moveTo(0, 0);
			ctx.lineTo(0, canvas.height);
			ctx.lineTo(canvas.width, canvas.height);
			ctx.lineTo(canvas.width, 0);

			ctx.stroke();

			const code = readBarcodeFromCanvas(canvas, format.value, mode.value === 'true');
			if (code.format) {
				resultElement.innerText = code.format + ": " + escapeTags(code.text);
				drawResult(code)
				// console.log(code.text);
				// Get data from api using barcode
				// code = 3760289220694
				// url = https://mirabelle.openfoodfacts.org/rappelconso_v2_gtin_trie/rappelconso_v2_gtin_trie.json?_sort=rowid&%EF%BB%BFgtin__exact=3760289220694&_shape=array

				fetch(`https://mirabelle.openfoodfacts.org/rappelconso_v2_gtin_trie/rappelconso_v2_gtin_trie.json?_sort=rowid&%EF%BB%BFgtin__exact=${code.text}&_shape=array`)
					.then(response => response.json())
					.then(data => {
						console.log(data);
						if (data.length > 0) {
							// Display popup with the result
							// CHeck if response is 200
							resultElement.innerText = code.format + ": " + escapeTags(code.text);

							// Get the modal
// Display popup with the result
var modal = document.getElementById("myModal");
var popupContent = document.getElementById("popupwide");

// Convert JSON to key-value pairs and render as an HTML table or list
let htmlContent = "<table style='width: 100%; border-collapse: collapse;'>";
htmlContent += "<thead><tr style='background: #f4f4f4;'><th style='border: 1px solid #ddd; padding: 8px; text-align: left;'>Field</th><th style='border: 1px solid #ddd; padding: 8px; text-align: left;'>Value</th></tr></thead>";
htmlContent += "<tbody>";

// Loop through the JSON object and create rows for each key-value pair
Object.entries(data[0]).forEach(([key, value]) => {
    htmlContent += `<tr>
        <td style='border: 1px solid #ddd; padding: 8px; font-weight: bold;'>${escapeTags(key)}</td>
        <td style='border: 1px solid #ddd; padding: 8px;'>${escapeTags(value.toString())}</td>
    </tr>`;
});

htmlContent += "</tbody></table>";

popupContent.innerHTML = htmlContent;
modal.style.display = "block";

						} else {
							resultElement.innerText = code.format + ": " + escapeTags(code.text);
						}
					})
					.catch((error) => {
						console.error('Error:', error);
					});

				// Display popup with the result
				resultElement.innerText = code.format + ": " + escapeTags(code.text);
			} else {
				// resultElement.innerText = "No barcode found";
			}
			requestAnimationFrame(processFrame);
		};

		const updateVideoStream = function (deviceId) {
			// To ensure the camera switch, it is advisable to free up the media resources
			if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

			navigator.mediaDevices
				.getUserMedia({ video: { facingMode: deviceId }, audio: false })
				.then(function (stream) {
					video.srcObject = stream;
					video.setAttribute("playsinline", true); // required to tell iOS safari we don't want fullscreen
					video.play();
					processFrame();
				})
				.catch(function (error) {
					console.error("Error accessing camera:", error);
				});
		};

		cameraSelector.addEventListener("change", function () {
			updateVideoStream(this.value);
		});
		var span = document.getElementsByClassName("close")[0];

		// When the user clicks on <span> (x), close the modal
		span.onclick = function() {
		modal.style.display = "none";
		}

		// When the user clicks anywhere outside of the modal, close it
		window.onclick = function(event) {
		if (event.target == modal) {
			modal.style.display = "none";
		}
		}
		updateVideoStream();
	</script>
</body>

</html>
